'''
이 문제를 해결하기 위해 우리는 모든 가능한 점프 경로를 찾아야 합니다. 
먼저, 점프는 현재 색상과 다른 색상의 칸으로만 가능하고, 점프는 오른쪽과 아래쪽 방향으로만 해야 하며, 두 번의 점프만 허용됩니다. 
따라서 이 문제는 두 번의 점프로 탐색할 수 있는 모든 가능한 경로를 계산해야 하는 문제입니다.

시작 지점은 항상 (1,1)이고, 도착 지점은 항상 (R,C)입니다. 
먼저 첫 번째 점프가 가능한 모든 지점을 찾은 후, 각 지점에서 두 번째 점프가 가능한 지점을 찾습니다. 
점프가 가능한지 확인하기 위해 현재 위치의 색과 점프 후 위치의 색이 다른지 확인해야 합니다.

접근 방식은 다음과 같습니다:
1. 가능한 모든 첫 번째 점프 지점을 찾습니다.
2. 각 첫 번째 점프 지점에서 가능한 두 번째 점프 지점을 찾습니다.
3. 각 두 번째 점프 지점에서 도착점으로 이동 가능한지 확인합니다.
4. 모든 조건을 만족하는 경로의 수를 계산합니다.
'''

def count_possible_jumps(R, C, board):
    # 가능한 점프 경로의 수를 저장할 변수
    count = 0

    # 첫 번째 점프를 위한 모든 가능한 위치 탐색
    for i in range(1, R):
        for j in range(1, C):
            # 시작 위치와 첫 번째 점프 위치의 색이 달라야 함
            if board[0][0] != board[i][j]:
                # 첫 번째 점프 후 두 번째 점프를 위한 모든 가능한 위치 탐색
                for k in range(i + 1, R):
                    for l in range(j + 1, C):
                        # 첫 번째 점프 위치와 두 번째 점프 위치의 색이 달라야 하며,
                        # 두 번째 점프 위치와 도착점의 색이 달라야 함
                        if board[i][j] != board[k][l] and board[k][l] != board[R - 1][C - 1]:
                            count += 1

    return count

R, C = map(int, input().split())
board = [input().split() for _ in range(R)]

# 가능한 점프 경로의 수를 계산하고 출력
print(count_possible_jumps(R, C, board))