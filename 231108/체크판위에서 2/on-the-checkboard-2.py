'''
제가 제안한 접근 방식에는 몇 가지 문제가 있습니다. 
첫째, 모든 점프 조합을 고려할 때, 마지막 점프가 실제로 최종 목적지인 (R, C)에 도착하는지 확인하지 않았습니다. 
둘째, 각 점프가 이전 점프 이후의 위치에서만 발생해야 한다는 조건을 고려하지 않았습니다.

이를 해결하기 위해서는 다음과 같은 알고리즘을 적용해야 합니다:
1. 첫 번째 점프 후의 위치를 확인합니다. 이 위치는 (1,1)에서 오른쪽으로 한 칸 이상, 아래로 한 칸 이상 이동한 지점이어야 합니다.
2. 두 번째 점프는 첫 번째 점프 후의 위치에서 시작해야 하며, 동일하게 오른쪽으로 한 칸 이상, 아래로 한 칸 이상 이동해야 합니다.
3. 두 번째 점프 후의 위치는 최종 목적지 (R, C)에 도착해야 합니다.
4. 각 점프는 서로 다른 색의 칸으로만 가능해야 합니다.
'''

def count_possible_jumps(R, C, board):
    # 가능한 점프 경로의 수를 저장할 변수
    count = 0
    
    # 첫 번째 점프는 (1, 1)에서 오른쪽과 아래로 한 칸 이상 이동해야 함
    for i in range(1, R - 1):   # 마지막 행은 제외
        for j in range(1, C - 1):   # 마지막 열은 제외
            # 시작 위치와 첫 번째 점프 위치의 색이 다르고, 첫 번째 점프 위치와 다음 점프 위치의 색이 다를 때만 유효
            if board[0][0] != board[i][j]:
                # 두 번째 점프는 첫 번째 점프 위치에서 오른쪽과 아래로 한 칸 이상 이동해야 함
                for k in range(i + 1, R):
                    for l in range(j + 1, C):
                        # 마지막 점프는 반드시 (R, C)로 이동해야 함
                        if (k == R - 1 and l == C - 1) and (board[i][j] != board[k][l]):
                            count += 1

    return count

R, C = map(int, input().split())
board = [input().split() for _ in range(R)]

# 가능한 점프 경로의 수를 계산하고 출력
print(count_possible_jumps(R, C, board))